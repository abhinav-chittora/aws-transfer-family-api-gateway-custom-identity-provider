---
AWSTemplateFormatVersion: '2010-09-09'
Description: Provides a template for creating an AWS Transfer for SFTP service.
  The service use API Gateway for authentication endpoint as IdP.
Parameters:
  CreateServer:
    AllowedValues:
      - 'true'
    Type: String
    Description: If a server is created, the customer identity provider
      is automatically associated with it.
    Default: 'true'
  SecretsManagerRegion:
    Type: String
    Description: (Optional) The region the secrets are stored in.
    Default: 'eu-central-1'
  AzureADClientID:
    Type: String
    Description: The client ID of the Azure AD application.
  AzureADTenantID:
    Type: String
    Description: The tenant ID of the Azure AD tenant.
  AzureADDomain:
    Type: String
    Description: The domain of the Azure AD tenant.

Conditions:
  CreateServer:
    Fn::Equals:
      - Ref: CreateServer
      - 'true'
  NotCreateServer:
    Fn::Not:
      - Condition: CreateServer
  SecretsManagerRegionProvided:
    Fn::Not:
      - Fn::Equals:
          - Ref: SecretsManagerRegion
          - ''
Resources:
  # Use SecretManager for AzureADClientID, AzureADTenantID, AzureADDomain
  AzureADClientIDSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: SFTP/AzureADClientID
      Description: The client ID of the Azure AD application.
      SecretString: !Sub 
        - '{"AzureADClientID": "${ClientIDParam}" }'
        - ClientIDParam: !Ref AzureADClientID
  AzureADTenantIDSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: SFTP/AzureADTenantID
      Description: The tenant ID of the Azure AD tenant.
      SecretString: !Sub 
        - '{"AzureADTenantID": "${TenantIDParam}" }'
        - TenantIDParam: !Ref AzureADTenantID
  AzureADDomainSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: SFTP/AzureADDomain
      Description: The domain of the Azure AD tenant.
      SecretString: !Sub 
        - '{"AzureADDomain": "${DomainParam}" }'
        - DomainParam: !Ref AzureADDomain

  #Elastic IPs to be used for SFTP server. Two IPs used for HA
  EIPTran01:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
  EIPTran02:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
  #Create S3 Bucket and Transfer Role
  EncryptedS3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      AccessControl: Private
      BucketName: !Sub 'sftp-${AWS::Region}-${AWS::AccountId}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
            BucketKeyEnabled: true
      LifecycleConfiguration:
        Rules:
        - Id: GlacierRule
          Status: Enabled
          ExpirationInDays: '30'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
  S3TransferAccessRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - transfer.amazonaws.com
          Action:
          - sts:AssumeRole
  S3TransferAccessManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Action:
            - s3:ListBucket
          Resource: !GetAtt EncryptedS3Bucket.Arn
        - Effect: Allow
          Action:
            - s3:GetBucketLocation
          Resource: !GetAtt EncryptedS3Bucket.Arn
        - Effect: Allow
          Action:
            - s3:ListAllMyBuckets
            - s3:GetBucketLocation
          Resource: "*"
        - Effect: Allow
          Action:
          - s3:PutObject
          - s3:GetObject
          - s3:DeleteObjectVersion
          - s3:DeleteObject
          - s3:GetObjectVersion
          Resource: !Sub "${EncryptedS3Bucket.Arn}/*"
      Roles:
      - !Ref S3TransferAccessRole
  TransferFamilyGroupAccessTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-group-access'
      AttributeDefinitions:
      - AttributeName: Id
        AttributeType: S
      - AttributeName: Directory
        AttributeType: S
      KeySchema:
      - AttributeName: Id
        KeyType: HASH
      - AttributeName: Directory
        KeyType: RANGE
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5
      Tags:
        - Key: Name
          Value: TransferFamilyGroupAccessTable
        - Key: Purpose
          Value: TransferFamilyGroupAccessTable
  #Creation of SFTP server
  TransferServer:
    Type : AWS::Transfer::Server
    Condition: CreateServer
    Properties :
      EndpointDetails:
        AddressAllocationIds:
          - !GetAtt EIPTran01.AllocationId
          - !GetAtt EIPTran02.AllocationId
        SubnetIds:
          - !ImportValue sftp-networksetup-Subnet1Id
          - !ImportValue sftp-networksetup-Subnet2Id

        VpcId: !ImportValue sftp-networksetup-VpcId
        SecurityGroupIds:
          - !ImportValue sftp-networksetup-SecurityGroupId
        # VpcEndpointId: !Ref TrVPCEndpoint (Not supported)
      EndpointType: VPC
      IdentityProviderDetails:
        InvocationRole:
          Fn::GetAtt: TransferIdentityProviderRole.Arn
        Url: !Sub 
          - "https://${CustomIdentityProviderApi}.execute-api.${AWS::Region}.amazonaws.com/${ApiStage}"
          - CustomIdentityProviderApi: !Ref CustomIdentityProviderApi
            ApiStage: !Ref ApiStage
      IdentityProviderType: API_GATEWAY
      PreAuthenticationLoginBanner: "This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel."
      LoggingRole:
        Fn::GetAtt: CloudWatchLoggingRole.Arn
      Tags:
        - Key: Name
          Value: SFTPServer
  CloudWatchLoggingRole:
    Description: IAM role used by Transfer to log API requests to CloudWatch
    Type: AWS::IAM::Role
    Condition: CreateServer
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - transfer.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: TransferLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogStreams
                  - logs:PutLogEvents
                Resource:
                  Fn::Sub: '*'
  CustomIdentityProviderApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: Transfer Custom Identity Provider API
      Description: API used for GetUserConfig requests
      FailOnWarnings: true
      EndpointConfiguration:
        Types:
        - REGIONAL
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
      - PolicyName: LambdaSecretsPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - secretsmanager:GetSecretValue
            Resource:
              Fn::Sub:
                - arn:aws:secretsmanager:${SecretsRegion}:${AWS::AccountId}:secret:SFTP/*
                - SecretsRegion:
                    Fn::If:
                      - SecretsManagerRegionProvided
                      - Ref: SecretsManagerRegion
                      - Ref: AWS::Region
      - PolicyName: LambdaDynamoDBPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:Scan
            Resource:
              Fn::Sub:
                - arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                - tableName: !Ref TransferFamilyGroupAccessTable
  ApiCloudWatchLogsRole:
    Description: IAM role used by API Gateway to log API requests to CloudWatch
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - apigateway.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
      - PolicyName: ApiGatewayLogsPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:DescribeLogGroups
            - logs:DescribeLogStreams
            - logs:PutLogEvents
            - logs:GetLogEvents
            - logs:FilterLogEvents
            Resource: "*"
  ApiLoggingAccount:
    Type: AWS::ApiGateway::Account
    DependsOn:
    - CustomIdentityProviderApi
    - ApiCloudWatchLogsRole
    Properties:
      CloudWatchRoleArn:
        Fn::GetAtt: ApiCloudWatchLogsRole.Arn
  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId:
        Ref: ApiDeployment
      RestApiId:
        Ref: CustomIdentityProviderApi
      StageName: prod
      AccessLogSetting:
        DestinationArn: !GetAtt ApiGatewayAccessLogGroup.Arn
        Format: '{ "requestId":"$context.requestId", "ip": "$context.identity.sourceIp", "caller":"$context.identity.caller", "user":"$context.identity.user","requestTime":"$context.requestTime", "httpMethod":"$context.httpMethod","resourcePath":"$context.resourcePath", "status":"$context.status","protocol":"$context.protocol", "responseLength":"$context.responseLength" }'
      MethodSettings:
        - DataTraceEnabled: false
          HttpMethod: '*'
          LoggingLevel: INFO
          ResourcePath: '/*'
          MetricsEnabled: true
  # Add CloudWatch Log Group for API Gateway Access Logs
  ApiGatewayAccessLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${CustomIdentityProviderApi}/access-logs'
      RetentionInDays: 7
  # Add CloudWatch Log Group for API Gateway Execution Logs
  ApiGatewayExecutionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${CustomIdentityProviderApi}/execution-logs'
      RetentionInDays: 7
  ApiDeployment:
    DependsOn:
    - GetUserConfigRequest
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId:
        Ref: CustomIdentityProviderApi
      StageName: dummystagefordeployment
  TransferIdentityProviderRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: transfer.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
      - PolicyName: TransferCanInvokeThisApi
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - execute-api:Invoke
            Resource:
              Fn::Sub: arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${CustomIdentityProviderApi}/prod/GET/*
      - PolicyName: TransferCanReadThisApi
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - apigateway:GET
            Resource: "*"
  GetUserConfigLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile:
          Fn::Sub: |
            import json
            import os
            import urllib.request
            import urllib.parse
            import boto3
            from botocore.exceptions import ClientError
            secrets_client = boto3.client('secretsmanager')
            dynamodb = boto3.client('dynamodb')

            def get_secret(secret_name):
                response = secrets_client.get_secret_value(SecretId=secret_name)
                return response['SecretString']

            def dynamodb_put_item(table_name, item):
                dynamodb.put_item(TableName=table_name, Item=item)

            def dynamodb_get_item(table_name, key):
                response = dynamodb.get_item(TableName=table_name, Key=key)
                return response.get('Item')

            def dynamodb_search_item(table_name, key):
                response = dynamodb.scan(TableName=table_name, ScanFilter=key)
                return response.get('Items')

            def graph_api_request(url, data=None, headers=None):
                if headers is None:
                    headers = {}
                req = urllib.request.Request(url, data=data, headers=headers)
                try:
                    with urllib.request.urlopen(req) as response:
                        return json.loads(response.read().decode('utf-8'))
                except urllib.error.HTTPError as error:
                    print(f"HTTPError: {error}")
                    print(f"HTTPError: {error.read()}")
                    return False

            def get_user_access_token(username, password, client_id, tenant_id):
                credentials = {
                    'username': username,
                    'password': password,
                    'grant_type': 'password',
                    'scope': 'https://graph.microsoft.com/User.Read',
                    'response_type': 'token',
                    'client_id': client_id
                }
                data = urllib.parse.urlencode(credentials).encode('utf-8')
                url = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"

                try:
                    azure_token = graph_api_request(url=url, data=data, headers={
                        'Accept': 'application/json',
                        'Content-Type': 'application/x-www-form-urlencoded'
                    })
                    if 'access_token' not in azure_token:
                        print(
                            f"Auth failure: {azure_token.get('error', 'Unknown error')}")
                        return {}
                        
                except urllib.error.HTTPError as e:
                    print(f"Auth failure: {e.read().decode('utf-8')}")
                    return {}

                return azure_token['access_token']

            def get_user_groups(username, access_token, tenant_id):
                try:
                    full_url = f"https://graph.microsoft.com/v1.0/users/{username}/memberOf/microsoft.graph.group?$select=displayName,id"
                    resp_data = graph_api_request(url=full_url, headers={
                        'Accept': 'application/json',
                        'Authorization': f"Bearer {access_token}"
                    })
                    if resp_data and 'value' in resp_data:
                        sftp_groups = [group for group in resp_data['value']
                                      if 'sftp' in group.get('displayName', '').lower()]
                    else:
                        print("Groups not found or other error occurred")
                        return {}
                except urllib.error.HTTPError as e:
                    print(f"Error occurred while fetching group {e}")
                    return {}
                
                return sftp_groups

            def get_additional_directory_prefixes(dynamodb_table_name, home_directory, s3_bucket_name, azure_domain=None,sftp_groups=None):
                directory_resources = []
                directory_resources.append(f'arn:aws:s3:::{home_directory}/*')
                allowed_prefixes = [
                    "",
                ]
                # Add group directories
                if sftp_groups is None:
                    sftp_groups = []
                for group in sftp_groups:
                    group_id = group['id']
                    group_name = group.get('displayName', '')
                    key = {'Id': {'S': group_id}, 'Directory': {'S': group_name}}
                    group_item = dynamodb_get_item(table_name=dynamodb_table_name, key=key)
                    if group_item:
                        group_directory = group_item.get('Directory', {}).get('S', '')
                        directory_resources.append(f'arn:aws:s3:::{s3_bucket_name}/{azure_domain}/{group_directory}/*')
                        allowed_prefixes.append(f"{azure_domain}/{group_directory}/*")
                    else:
                        print(f"No directory found for group {group_name}")

                # Debug print statements
                print(f"directory_resources: {directory_resources}")
                print(f"allowed_prefixes: {allowed_prefixes}")

                return allowed_prefixes, directory_resources

            def generate_s3_policy(s3_bucket_name, home_directory, allowed_prefixes, directory_resources):
                user_scoped_s3_policy = policy = {
                    'Version': '2012-10-17',
                    'Statement': [
                        {
                            'Sid': 'AllowRootAndDomainListing',
                            'Effect': 'Allow',
                            'Action': ['s3:ListBucket', 's3:GetBucketLocation'],
                            'Resource': [f'arn:aws:s3:::{s3_bucket_name}'],
                            'Condition': {
                                'StringEquals': {
                                    's3:prefix': allowed_prefixes
                                }
                            }
                        },
                        {
                            'Sid': 'AllowUserHomeDirectoryListing',
                            'Effect': 'Allow',
                            'Action': ['s3:ListBucket', 's3:GetBucketLocation'],
                            'Resource': [f'arn:aws:s3:::{s3_bucket_name}']
                        },
                        {
                            'Sid': 'AllowUserHomeAccess',
                            'Effect': 'Allow',
                            'Action': [
                                's3:PutObject',
                                's3:GetObject',
                                's3:DeleteObjectVersion',
                                's3:DeleteObject',
                                's3:GetObjectVersion'
                            ],
                            'Resource': [f'arn:aws:s3:::{home_directory}/*']
                        },
                        {
                            'Sid': 'AllowGroupDirectoryAccess',
                            'Effect': 'Allow',
                            'Action': [
                                's3:GetObject',
                                's3:PutObject',
                                's3:DeleteObject',
                                's3:DeleteObjectVersion',
                                's3:GetObjectVersion'
                            ],
                            'Resource': directory_resources
                        },
                        {
                            'Sid': 'DenyDeletionOfHomeDirectory',
                            'Effect': 'Deny',
                            'Action': ['s3:DeleteObjectVersion', 's3:DeleteObject'],
                            'Resource': [f'arn:aws:s3:::{home_directory}/']
                        }
                    ]
                }
                return user_scoped_s3_policy

            def lambda_handler(event, context):
                resp_data = {}

                # Standard Variables for SFTP Auth
                s3_bucket_name = os.environ['S3BucketName']
                s3_role_arn = os.environ['S3RoleARN']    
                dynamodb_table_name = os.environ['DynamoDBTableName']

                # Validation of Inputs and Events
                if 'username' not in event or 'serverId' not in event:
                    print("Incoming username or serverId missing  - Unexpected")
                    return resp_data
                if 'password' in event and event['password'] != "":
                    input_password = event['password']        
                    # Use SecretManager to get these values
                    azure_client_id = json.loads(get_secret("SFTP/AzureADClientID"))['AzureADClientID']
                    azure_domain = json.loads(get_secret("SFTP/AzureADDomain"))['AzureADDomain']
                    azure_tenant_id = json.loads(get_secret("SFTP/AzureADTenantID"))['AzureADTenantID']
                    user = f"{event['username']}@{azure_domain}"
                    home_directory = f"{s3_bucket_name}/{azure_domain}/{user}"
                    print(f"Authenticating user via Graph API: {user}")
                    try: 
                        access_token = get_user_access_token(user, input_password, azure_client_id, azure_tenant_id)
                    except urllib.error.HTTPError as e:
                        print(f"Auth failure: {e.read().decode('utf-8')}")
                        return resp_data
                    sftp_groups = get_user_groups(user, access_token, azure_tenant_id)
                    allowed_prefixes, directory_resources = get_additional_directory_prefixes(dynamodb_table_name=dynamodb_table_name, sftp_groups=sftp_groups, s3_bucket_name=s3_bucket_name, azure_domain=azure_domain, home_directory=home_directory)
                    user_scoped_s3_policy = generate_s3_policy(s3_bucket_name, home_directory, allowed_prefixes, directory_resources)
                    resp_data = {
                        "Status": "success",
                        "Role": s3_role_arn,
                        "Policy": json.dumps(user_scoped_s3_policy),
                        "HomeDirectory" : f"/{s3_bucket_name}/{azure_domain}/{user}"
                    }
                else:
                    print("No password, checking for SSH public key")
                    input_password = ''
                    user = event['username']
                    home_directory = f"{s3_bucket_name}/{user}"
                    # Check DynamoDB for SSH Public Key
                    key = {'Id': {'S': user}, 'Directory': {'S': user}}
                    user_item = dynamodb_get_item(table_name=dynamodb_table_name, key=key)
                    if user_item:
                        ssh_public_key = user_item.get('SSHPublicKey', {}).get('S', '')
                        if ssh_public_key:
                            print(f"SSH Public Key found for user {user}")

                            allowed_prefixes, directory_resources = get_additional_directory_prefixes(dynamodb_table_name=dynamodb_table_name, s3_bucket_name=s3_bucket_name, home_directory=home_directory)
                            user_scoped_s3_policy = generate_s3_policy(s3_bucket_name, home_directory, allowed_prefixes, directory_resources)
                            resp_data = {
                                "Status": "success",
                                "Role": s3_role_arn,
                                "Policy": json.dumps(user_scoped_s3_policy),
                                "HomeDirectory" : f"/{s3_bucket_name}/{user}",
                                "PublicKeys": [ssh_public_key]
                            }
                        else:
                            print(f"No SSH Public Key found for user {user}")
                            resp_data = {
                                "Status": "failure",
                                "Message": "No SSH Public Key found for user"
                            }
                print(f"Response: {resp_data}")
                return resp_data
      Description: A function to lookup and return user data from AWS Secrets Manager.
      Handler: index.lambda_handler
      Role:
        Fn::GetAtt: LambdaExecutionRole.Arn
      Runtime: python3.11
      Environment:
        Variables:
          AzureADClientID: ${AzureADClientID}
          AzureADDomain: ${AzureADDomain}
          AzureADTenantID: ${AzureADTenantID}
          S3BucketName: !Ref EncryptedS3Bucket
          S3RoleARN: !GetAtt S3TransferAccessRole.Arn
          DynamoDBTableName: !Ref TransferFamilyGroupAccessTable
          SecretsManagerRegion:
            Fn::If:
              - SecretsManagerRegionProvided
              - Ref: SecretsManagerRegion
              - Ref: AWS::Region
  GetUserConfigLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:invokeFunction
      FunctionName:
        Fn::GetAtt: GetUserConfigLambda.Arn
      Principal: apigateway.amazonaws.com
      SourceArn:
        Fn::Join:
        - ''
        - - 'arn:aws:execute-api:'
          - Ref: AWS::Region
          - ":"
          - Ref: AWS::AccountId
          - ":"
          - Ref: CustomIdentityProviderApi
          - "/*"
  ServersResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId:
        Ref: CustomIdentityProviderApi
      ParentId:
        Fn::GetAtt:
        - CustomIdentityProviderApi
        - RootResourceId
      PathPart: servers
  ServerIdResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId:
        Ref: CustomIdentityProviderApi
      ParentId:
        Ref: ServersResource
      PathPart: "{serverId}"
  UsersResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId:
        Ref: CustomIdentityProviderApi
      ParentId:
        Ref: ServerIdResource
      PathPart: users
  UserNameResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId:
        Ref: CustomIdentityProviderApi
      ParentId:
        Ref: UsersResource
      PathPart: "{username}"
  GetUserConfigResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId:
        Ref: CustomIdentityProviderApi
      ParentId:
        Ref: UserNameResource
      PathPart: config
  GetUserConfigRequest:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: AWS_IAM
      HttpMethod: GET
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri:
          Fn::Join:
          - ''
          - - 'arn:aws:apigateway:'
            - Ref: AWS::Region
            - ":lambda:path/2015-03-31/functions/"
            - Fn::GetAtt:
              - GetUserConfigLambda
              - Arn
            - "/invocations"
        IntegrationResponses:
        - StatusCode: 200
        RequestTemplates:
          application/json: |
            {
              "username": "$input.params('username')",
              "serverId": "$input.params('serverId')",
              "password": "$util.escapeJavaScript($input.params('Password')).replaceAll(".*", "********")",
              "protocol": "$input.params('protocol')",
              "sourceIp": "$input.params('sourceIp')"
            }
        PassthroughBehavior: WHEN_NO_TEMPLATES
      RequestParameters:
        method.request.header.Password: false
        method.request.querystring.protocol: false
        method.request.querystring.sourceIp: false
        method.request.path.username: true
        method.request.path.serverId: true
      MethodResponses:
      - StatusCode: 200
        ResponseModels:
          application/json: UserConfigResponseModel
      ResourceId:
        Ref: GetUserConfigResource
      RestApiId:
        Ref: CustomIdentityProviderApi
  GetUserConfigResponseModel:
    Type: AWS::ApiGateway::Model
    Properties:
      RestApiId:
        Ref: CustomIdentityProviderApi
      ContentType: application/json
      Description: API response for GetUserConfig
      Name: UserConfigResponseModel
      Schema:
        "$schema": http://json-schema.org/draft-04/schema#
        title: UserConfigResponse
        type: object
        properties:
          status:
            type: string
          Role:
            type: string
          Policy:
            type: string
          HomeDirectoryType:
            type: string
          HomeDirectoryMappings:
            type: array
            items:
              type: object
              properties:
                Entry:
                  type: string
                Target:
                  type: string
  TrSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow Internet connection to SFTPServer
      VpcId: !ImportValue sftp-networksetup-VpcId
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
      - CidrIp: 127.0.0.1/32
        IpProtocol: "-1"
      Tags:
      - Key: Name
        Value: sg-sftp-production
  TrDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardBody:
        !Sub
        - '{
            "widgets": [
                {
                    "type": "metric",
                    "x": 0,
                    "y": 0,
                    "width": 12,
                    "height": 3,
                    "properties": {
                        "metrics": [
                            [ "AWS/Transfer", "BytesIn", "ServerId", "${TransferServerID}" ],
                            [ ".", "BytesOut", ".", "." ]
                        ],
                        "view": "singleValue",
                        "region": "${AWS::Region}",
                        "stat": "Sum",
                        "period": 604800,
                        "title": "Transfer Bytes"
                    }
                },
                {
                    "type": "log",
                    "x": 0,
                    "y": 3,
                    "width": 12,
                    "height": 6,
                    "properties": {
                        "query": "SOURCE ''/aws/transfer/${TransferServerID}'' | filter @message like \"OPEN\" | parse @message \"*.* OPEN Path=* Mode=*\" as user, sessionID, path, mode | fields @timestamp | sort @timestamp desc | stats count_distinct(sessionID) as uniquesessions by bin(10min)",
                        "region": "${AWS::Region}",
                        "title": "Unique Sessions",
                        "view": "bar"
                    }
                },
                {
                    "type": "log",
                    "x": 12,
                    "y": 12,
                    "width": 12,
                    "height": 6,
                    "properties": {
                        "query": "SOURCE ''/aws/transfer/${TransferServerID}'' | filter @message like \"READ\" | fields @timestamp | sort @timestamp desc | stats count(*) as FileRead by bin(10min)",
                        "region": "${AWS::Region}",
                        "title": "Get Operations",
                        "view": "bar"
                    }
                },
                {
                    "type": "log",
                    "x": 12,
                    "y": 6,
                    "width": 12,
                    "height": 6,
                    "properties": {
                        "query": "SOURCE ''/aws/transfer/${TransferServerID}'' | filter @message like \"WRITE\" | fields @timestamp | sort @timestamp desc | stats count(*) as FileWrite by bin(10min)",
                        "region": "${AWS::Region}",
                        "stacked": false,
                        "title": "Put Operations",
                        "view": "bar"
                    }
                },
                {
                    "type": "log",
                    "x": 0,
                    "y": 9,
                    "width": 12,
                    "height": 9,
                    "properties": {
                        "query": "SOURCE ''/aws/transfer/${TransferServerID}'' | filter @message like \"ERROR\" | fields @timestamp | sort @timestamp desc | stats count(*) as Errors by bin(24hr)",
                        "region": "${AWS::Region}",
                        "title": "Error Count",
                        "view": "bar"
                    }
                },
                {
                    "type": "log",
                    "x": 12,
                    "y": 0,
                    "width": 12,
                    "height": 6,
                    "properties": {
                        "query": "SOURCE ''/aws/transfer/${TransferServerID}'' | filter @message like \"OPEN\" | parse @message \"*.* OPEN Path=* Mode=*\" as user, sessionID, path, mode | fields @timestamp | filter mode like \"READ\" | sort path desc | stats count(path) as NumberOfRequests by path | limit 10",
                        "region": "${AWS::Region}",
                        "title": "Top File Downloads",
                        "view": "table"
                    }
                }
            ]}'
        - TransferServerID: !GetAtt TransferServer.ServerId

Outputs:
  ServerId:
    Value:
      Fn::GetAtt: TransferServer.ServerId
    Condition: CreateServer
  ServerEndpoint:
    Value:
      Fn::Join:
      - ''
      - - Fn::GetAtt: TransferServer.ServerId
        - .server.transfer.
        - Ref: AWS::Region
        - .amazonaws.com
  TransferIdentityProviderUrl:
    Description: URL to pass to AWS Transfer CreateServer call as part of optional IdentityProviderDetails
    Value:
      Fn::Join:
      - ''
      - - https://
        - Ref: CustomIdentityProviderApi
        - .execute-api.
        - Ref: AWS::Region
        - .amazonaws.com/
        - Ref: ApiStage
  TransferIdentityProviderInvocationRole:
    Description: IAM Role to pass to AWS Transfer CreateServer call as part of optional IdentityProviderDetails
    Value:
      Fn::GetAtt: TransferIdentityProviderRole.Arn
  CloudWatchDashboard:
    Value: !Ref TrDashboard